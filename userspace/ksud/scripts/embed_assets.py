#!/usr/bin/env python3
"""
Generate C++ source file containing embedded binary assets.
Similar to xxd -i but generates a more usable format.
"""

import os
import sys
from pathlib import Path

# Path to installer.sh relative to this script
INSTALLER_SH_PATH = Path(__file__).parent.parent.parent / "ksud" / "src" / "installer.sh"

def to_c_identifier(name: str) -> str:
    """Convert filename to valid C identifier."""
    # Replace dots and dashes with underscores
    result = name.replace('.', '_').replace('-', '_')
    # Ensure it starts with a letter or underscore
    if result[0].isdigit():
        result = '_' + result
    return result

def generate_asset_array(filepath: Path) -> tuple[str, str, int]:
    """Generate C array for a single file."""
    name = to_c_identifier(filepath.name)
    
    with open(filepath, 'rb') as f:
        data = f.read()
    
    # Generate hex array
    hex_data = ', '.join(f'0x{b:02x}' for b in data)
    
    return name, hex_data, len(data)

def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <assets_dir> <output.cpp>")
        sys.exit(1)
    
    assets_dir = Path(sys.argv[1])
    output_file = Path(sys.argv[2])
    
    # Collect all files in assets directory
    assets = []
    if assets_dir.exists():
        for f in sorted(assets_dir.iterdir()):
            if f.is_file() and not f.name.startswith('.'):
                assets.append(f)
    
    # Generate C++ source
    output = '''// Auto-generated file - DO NOT EDIT
// Generated by embed_assets.py

#include "assets.hpp"
#include "defs.hpp"
#include "utils.hpp"
#include "log.hpp"
#include <cstring>
#include <map>
#include <sys/stat.h>
#include <cerrno>

namespace ksud {

'''
    
    # First, embed installer.sh as a string literal
    installer_content = ""
    if INSTALLER_SH_PATH.exists():
        with open(INSTALLER_SH_PATH, 'r') as f:
            installer_content = f.read()
        print(f"Embedding installer.sh from {INSTALLER_SH_PATH}")
    else:
        print(f"WARNING: installer.sh not found at {INSTALLER_SH_PATH}")
    
    # Generate escaped installer script content
    output += '// Installer script content (from ksud/src/installer.sh)\n'
    output += 'static const char* INSTALLER_CONTENT = R"INSTALLER_SCRIPT(\n'
    output += installer_content
    output += ')INSTALLER_SCRIPT";\n\n'
    
    # Generate install module script (installer.sh + install_module call)
    output += '''// Full install module script
const char* get_install_module_script() {
    static std::string script;
    if (script.empty()) {
        script = std::string(INSTALLER_CONTENT) + "\\ninstall_module\\nexit 0\\n";
    }
    return script.c_str();
}

'''
    
    # Generate arrays for each asset
    asset_infos = []
    for filepath in assets:
        name, hex_data, size = generate_asset_array(filepath)
        output += f'// Asset: {filepath.name}\n'
        output += f'static const unsigned char asset_{name}[] = {{\n'
        
        # Split into lines of 16 bytes
        bytes_list = hex_data.split(', ')
        for i in range(0, len(bytes_list), 16):
            output += '    ' + ', '.join(bytes_list[i:i+16]) + ',\n'
        
        output += f'}};\n'
        output += f'static const size_t asset_{name}_size = {size};\n\n'
        
        asset_infos.append((filepath.name, name, size))
    
    # Generate asset registry
    output += '''
struct AssetEntry {
    const char* name;
    const unsigned char* data;
    size_t size;
};

static const AssetEntry asset_registry[] = {
'''
    
    for filename, name, size in asset_infos:
        output += f'    {{"{filename}", asset_{name}, asset_{name}_size}},\n'
    
    output += '''    {nullptr, nullptr, 0}  // sentinel
};

const std::vector<std::string>& list_assets() {
    static std::vector<std::string> names;
    static bool initialized = false;
    if (!initialized) {
        for (const auto* entry = asset_registry; entry->name != nullptr; ++entry) {
            names.push_back(entry->name);
        }
        initialized = true;
    }
    return names;
}

bool get_asset(const std::string& name, const uint8_t*& data, size_t& size) {
    for (const auto* entry = asset_registry; entry->name != nullptr; ++entry) {
        if (name == entry->name) {
            data = entry->data;
            size = entry->size;
            return true;
        }
    }
    return false;
}

bool copy_asset_to_file(const std::string& name, const std::string& dest_path) {
    const uint8_t* data;
    size_t size;
    if (!get_asset(name, data, size)) {
        LOGE("Asset not found: %s", name.c_str());
        return false;
    }
    
    // Remove existing file first (like Rust version)
    unlink(dest_path.c_str());
    
    std::ofstream ofs(dest_path, std::ios::binary);
    if (!ofs) {
        LOGE("Failed to open file for writing: %s (errno=%d: %s)", dest_path.c_str(), errno, strerror(errno));
        return false;
    }
    ofs.write(reinterpret_cast<const char*>(data), size);
    if (!ofs.good()) {
        LOGE("Failed to write asset %s to %s", name.c_str(), dest_path.c_str());
        return false;
    }
    return true;
}

std::vector<std::string> list_supported_kmi() {
    std::vector<std::string> result;
    for (const auto& name : list_assets()) {
        // Format: android15-6.6_kernelsu.ko
        const char* suffix = "_kernelsu.ko";
        size_t suffix_len = strlen(suffix);
        if (name.size() > suffix_len && 
            name.compare(name.size() - suffix_len, suffix_len, suffix) == 0) {
            result.push_back(name.substr(0, name.size() - suffix_len));
        }
    }
    return result;
}

int ensure_binaries(bool ignore_if_exist) {
    if (!ensure_dir_exists(BINARY_DIR)) {
        LOGE("Failed to create binary directory: %s", BINARY_DIR);
        return 1;
    }
    
    for (const auto& name : list_assets()) {
        // Skip ksuinit and kernel modules - they are extracted on demand
        if (name == "ksuinit" || name.find("_kernelsu.ko") != std::string::npos) {
            continue;
        }
        
        std::string dest = std::string(BINARY_DIR) + name;
        
        if (ignore_if_exist) {
            struct stat st;
            if (stat(dest.c_str(), &st) == 0) {
                continue;
            }
        }
        
        if (!copy_asset_to_file(name, dest)) {
            LOGE("Failed to extract binary: %s", name.c_str());
            return 1;
        }
        chmod(dest.c_str(), 0755);
    }
    return 0;
}

} // namespace ksud
'''
    
    # Write output
    output_file.parent.mkdir(parents=True, exist_ok=True)
    with open(output_file, 'w') as f:
        f.write(output)
    
    print(f"Generated {output_file} with {len(assets)} assets")
    for filename, name, size in asset_infos:
        print(f"  - {filename}: {size} bytes")

if __name__ == '__main__':
    main()
